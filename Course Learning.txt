  ============= The Repository Pattern - Consequences ==============

== Increased Level of Abstraction.

== Increased Maintainablility, Flexibility,Testability.

== More Classes / Interfaces - less Duplicate Code .

== Business Logic further away from the data.

== Harder to Optmize certain Operations againist the data source.


============================ New Leearnings =============================

== In Our Startup Class, we Have two functions..
   
== First is ConfigureService. In this function we actually register the services.

== Ordering to add new services in this function does't matter.

== Second is Configure.

==  in this Function when we want to add new middleware then order of writing

   middleware is very important !!!


====  Three Methods for Register a new Service..

1- Add Transient and this one is instantiated for a individual method and not
 the request itself. it's got a very short lifetime the repository will be created
 and the destroyed just upon using an individual method, and that's too short.
 
2- Add a Singleton, by the use of this options the service would be created the 
 first time we use it when the application starts and the method goes to controller
and created a new instance of the repository but then it would never be destroyed
 until the application shuts down and that's too long.

3- Add a Scoped , this one is the Correct Option, and this is the one that we will
 use for almost everything.


- So It's gonna be created when the HTTP Request comes into our API Creates
a new Instance in the Controller, the Controller sees that it needs a repository
So it Creates the instance of Repository.
and when the request is finished then it disposes of both the controller and 
the repository.

And We Don't ourselves need to worry about disposing of the resources created

when a request comes Because of these life cycles.



==================== Why We Use LoggerFactory in .NET Core ====================
= logs have been an essential part of troubleshooting application 
 and infrastructure performance.

=  Log data contains information such as out of memory exception
   or hard disk errors .
== This feature we deployed last week was working fine till yesterday now 

 I have no idea why is it not working!" This is like a typical sentence you 

hear from developers when there is no logging in place. It can be to a great 

extent solved by having automated tests, still having logging and monitoring 

gives you a different viewpoint. In this post, I am going to reveal the 

importance of having logs for your code and monitoring your code to cut

 down the firefighting time for bugs and errors by huge margins.


== Generally, developers don't write any code that logs meaningful 

 and relevant messages for the feature they are writing. Writing code

 to log things may even be considered not essential and a waste of time 

by developers who work in small projects. Which might be true to some point 

but the benefits surely outweigh the cost.


== The solution is simple, make logs and writing code to do logging first

 class citizen in your code base. Logs are the medium through which your

 app speaks to you. Logging is the foundation for solving your operational 

problems so not having them is being in a communication void with your 

application.


== As an example, if you create a user, just log that the user has been 

created successfully and if the user could not be created because of 

let's say a database exception it is even more important to log the reason

 behind the unsuccessful operation.


===============================================================================

---------------- API Generic Repository ----------------------------------

-- It is very easy to register a service and their relevant repository which

   implements that specific repository.

-- but in case of Generic Repository , First of all we also need to add this to

   our service container so that we can inject less wherever in our program.

-- The Way that we add this is slightly different from this Because in this
 
   case we don't know the types that we are going to be using with this 
 
   repository at this time.
            services.AddScoped(typeof(IGenericRepository<>),typeof(GenericRepository<>));


--- .NET Core — Using the Specification pattern alongside a generic Repository---

-- The Repository and Unit of Work pattern are intended to create an abstraction layer 

between the business logic layer and the data access layer of an application.


------------------------- The Specification pattern ----------------------------

-The Specification pattern allows us to encapsulate some piece of domain knowledge
 
 into a single unit (the specification) and reuse it in different parts of the code base.

- It provides us a good solution to the problem of where to place the querying, sorting and

  paging logic since it describes a query in an object.

- Why and how we should mix them?

== In a large application with many domain objects and many possible queries, 
 
the Repository pattern reduces the amount of code needed to deal with all the

 querying that is needed. Adding to this, a generic Repository promotes the 

Specification pattern, which encapsulates the query to be performed in a pure
 
 object-oriented way. We can simply write code purely in terms of object and 
 
  put SQL in the background.

-- For example, to encapsulate a paged query that searches for recipes and need 
  
 
to include the users that have made such recipes, we can create a SearchRecipesWithUsers 

specification which would take any parameters we need and have the overloads — allow a 

class to have more than one method having the same name, if their argument lists are 

different — we wish. The generic Repository would have a method that receives a specification 

as an argument and would be able to return the expected result according to the provided specification.

========================== Conclusion ======================================

== Using the Specification pattern with the Unit Of Work/Repository pattern provides us with a very modular 

  code, keeping our code organized and making it easy to add more complexity as the application grows.

== As said, there is no silver bullet when coding or architecting an application, but I consider this 
   approach as a good practice.


== Describes a query in an Object.

== Returns an IQuerable<T>

== Generic List method takes Specification as Paramerter.

== Specification Can  Have Meaningful Name.

 LIke , ProductsWithTypesBrandsSpecification

===================  What is AutoMapper?

== AutoMapper is a simple library that helps us to transform one object type

 to another. It is a convention-based object-to-object mapper that requires

 very little configuration. 

The object-to-object mapping works by transforming an input object of one type

 into an output object of a different type.


== Profiles
A good way to organize our mapping configurations is with Profiles. We need to 

create classes that inherit from Profile class and put the configuration in the

 constructor: 

== our application starts and initializes AutoMapper, AutoMapper will scan our application

 and look for classes that inherit from the Profile class and load their mapping configurations.